(module source-files (load-source-file!
		      sf-name
		      sf-token-lines
		      sf-types-env)
  (import scheme
	  (chicken base)
	  (chicken pathname)
	  (only (chicken file) file-exists?)
	  (only (chicken string) string-split conc)
	  (only (srfi-13) string-prefix?)
	  (only (chicken io) read-string)
	  (only (srfi-1) fold filter-map)
	  (srfi-69))
  (import tokenizer c-types c-tokens)

  (define source-files
    (make-hash-table equal?))

  (define (hash-table-lookup table key)
    (hash-table-ref/default table key #f))

  (define (hash-table-insert table key value)
    (hash-table-set! table key value)
    value)

;;; Return a list of all lines in the file behind
;;; filepath or '() if the file can't be read.
  (define (file->list filepath)
    ;; By keeping empty strings when splitting the
    ;; content at the newline characters, we accidentally
    ;; add another empty string to the end of the lines
    ;; list that's generated by the trailing newline at
    ;; the end of the file. The lines list is printed by
    ;; appending a newline to the end of each entry. Thereby,
    ;; we basically add another line to the end of the file
    ;; that doesn't actually exist. Here that line is removed.
    (define (omit-trailing-line! lines)
      (define (before-last lst)
	(if (null? lst)
	    '()
	    (let loop ((current lst)
		       (next (cdr lst)))
	      (if (null? (cdr next))
		  current
		  (loop (cdr current)
			(cdr next))))))
      (let ((pen (before-last lines)))
	(cond ((null? pen)
	       '())
	      ((equal? (cadr pen) "")
	       (set! (cdr pen) '())
	       lines)
	      (else
	       lines))))

    (if (file-exists? filepath)
	(call-with-input-file filepath
	  (lambda (port)
	    (let ((content (read-string #f port)))
	      (if (not content)
		  '()
		  (omit-trailing-line!
		   (string-split content "\n" #t))))))
	'()))


  (define (make-deps filepath includes)
    (list '*deps* filepath includes))

  (define (deps? deps)
    (and (pair? deps)
	 (eq? '*deps* (car deps))))

  (define (deps-file deps)
    (cadr deps))

  (define (deps-includes deps)
    (caddr deps))

  (define (filter-filepaths filepath token-lines)
    (define (strip-path-quotes str)
      (substring str
		 1
		 (- (string-length str)  1)))

    (define (find-local-header include-filepath)
      (make-pathname
       (pathname-directory filepath)
       include-filepath))

    (define search-paths
      (list "/usr/include" "/usr/local/include"))
    
    (define (find-system-header include-filepath)
      (let loop ((search-paths search-paths))
	(if (null? search-paths)
	    #f
	    (let ((check-filepath (make-pathname (car search-paths)
						 include-filepath)))
	      (if (file-exists? check-filepath)
		  check-filepath
		  (loop (cdr search-paths)))))))
    
    (define (find-location include-filepath search-type)
      (if (eq? search-type 'system-header)
	  (find-system-header include-filepath)
	  (find-local-header include-filepath)))

    (define (search-type filepath)
      (if (string-prefix? "<" filepath)
	  'system-header
	  'local-header))

    (filter-map
     (lambda (token)
       (if (eq? (token-tag token)
		token-tag-include-filepath)
	   (let ((filepath (token-text token)))
	     (find-location
	      (strip-path-quotes filepath)
	      (search-type filepath)))
	   #f))
     (flatten token-lines)))

  (define (make-sf token-lines deps types-env)
    (list '*source-file* token-lines deps types-env))

  (define (source-file? sf)
    (and (pair? sf)
	 (eq? '*source-file*
	      (car sf))))

  (define (sf-deps sf)
    (if (source-file? sf)
	(caddr sf)
	(error "sf-deps, not a source file" sf)))

;;; Flatten the given source file's dependency tree into
;;; a list of all unique files in it.
  (define (sf-flat-deps sf)
    (let ((flattened (make-hash-table equal?)))
      (let rec ((deps (sf-deps sf)))
	;; Continue this recursion only if this is a new dependency.
	(if (not (hash-table-exists? flattened (deps-file deps)))
	    (begin
	      (hash-table-set! flattened (deps-file deps) '())
	      (for-each
	       (lambda (dep)
		 (rec dep))
	       (deps-includes deps)))))
      (map
       (lambda (assoc)
	 (car assoc))
       (hash-table->alist flattened))))

  (define (sf-deps->token-lines-lst sf)
    (map
     (lambda (dep)
       (sf-token-lines
	(hash-table-ref source-files dep)))
     (sf-flat-deps sf)))

  (define (sf-name sf)
    (deps-file (sf-deps sf)))

  (define (sf-token-lines sf)
    (if (source-file? sf)
	(cadr sf)
	(error "sf-token-lines, not a source file" sf)))

  (define (sf-types-env sf)
    (define (_sf-types-env sf) (cadddr sf))
    (if (source-file? sf)
	;; Source files are created by calling `load-source-file`. This procedure
	;; doesn't initialize the types environment to save compute. The types
	;; environment doesn't know about the tree-structure of the dependencies
	;; at this point in time. Instead, it expects a flat list of inputs and
	;; output another flat data structure. If this changes, that is if the
	;; type environment becomes recursive, then it can be initialized in the
	;; `load-source-file` procedure instantly. This will likely save compute
	;; because linearizing the dependency tree is not needed anymore.
	(let ((types-env (_sf-types-env sf)))
	  (if (not (null? types-env))
	      types-env
	      (_sf-types-env
	       (hash-table-update! source-files
				   (sf-name sf)
				   (lambda (sf)
				     (make-sf
				      (sf-token-lines sf)
				      (sf-deps sf)
				      ;; Parse the types in the source file's dependency tree.
				      (apply make-types-env
					     (sf-deps->token-lines-lst sf))))))))))

  (define (load-source-file! filepath)
    (let ((lookup (hash-table-lookup source-files filepath)))
      (if lookup
	  lookup	   ; The file has been read already. Return that result.
	  (let ((token-lines (tokenize	; Read this new file.
			      (file->list filepath))))
	    (if (not token-lines)
		'()
		(begin		      ; Recurse over all of the file's includes.
		  (let loop ((filepaths (filter-filepaths filepath token-lines))
			     (includes '()))
		    (if (pair? filepaths)
			;; Load the dependencies of this include filepath and continue
			;; with the next one.
			(loop
			 (cdr filepaths)
		 	 (cons (sf-deps
				(load-source-file! (car filepaths)))
			       includes))
			;; All include filepaths were processed. Store the source
			;; file for the current file and return it.
			(hash-table-insert source-files
					   filepath
					   (make-sf
					    token-lines
					    (make-deps filepath
						       includes)
					    '()))))))))))

  ;; End of module source-files.
  )


(module print-source (print-source)
  (import scheme
	  (chicken base)
	  (only traversal sublist))
  (import tokenizer source-files)


;;; Create a sublist without exceeding the range of `lst`.
;;; Saturates on both ends if either index is out of range.
  (define (sat-sublist lst start end)
    (define (sat-start)
      (cond ((< start 0)
	     0)
	    ((< start (length lst))
	     start)
	    (else
	     ;; The start index is inclusive.
	     (- (length lst) 1))))
    (define (sat-end)
      (cond ((< end 0)
	     0)
	    ((< end (length lst))
	     end)
	    (else
	     ;; The end index is exclusive.
	     (length lst))))
    (sublist lst (sat-start) (sat-end)))

  (define (start-lineno lineno n-context-lines)
    (if (> lineno n-context-lines)
	(- lineno n-context-lines)
        1))

  (define (end-lineno lineno n-context-lines)
    (+ lineno n-context-lines 1
       ;; Extend window downward if there
       ;; aren't enough lines above.
       (if (< lineno n-context-lines)
	   (- n-context-lines lineno)
	   0)))

  (define (line-window lines lineno n-context-lines)
    (let ((start-lineno (start-lineno lineno n-context-lines))
	  (end-lineno (end-lineno lineno n-context-lines)))
      (sat-sublist lines
		   (- start-lineno 1)
		   (- end-lineno 1))))

;;; Print the source code at the `filepath`:`lineno` with
;;; `n-context-lines` above and below `lineno`. Returns #f
;;; on error and #t on success.
  (define (print-source filepath lineno n-context-lines use-color)
    (let ((source-file (load-source-file! filepath))
	  (start-lineno (start-lineno lineno n-context-lines)))
      (if (not source-file)
	  #f
	  (begin
	    (display
    	     (color-tokens
	      (line-window (sf-token-lines source-file)
			   lineno
			   n-context-lines)
	      (sf-types-env source-file)
	      start-lineno
	      lineno
	      use-color))
	    #t))))
  ;; End module print-source.
  )

(import print-source)

(cond-expand
  ;; FFI is not allowed in interpreted mode.
  (compiling
   (begin
     (import (chicken foreign)
	     (chicken platform))
     (define-external (print_source_extern (c-string filepath)
					   (unsigned-int lineno)
					   (unsigned-int n_context_lines)
					   (bool use-color))
       int
       (if (print-source filepath lineno n_context_lines use-color)
	   0
	   -1))
     (return-to-host)))
  (else ))
