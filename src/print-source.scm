(module print-source (print-source)
  (import scheme
	  (chicken base)
	  (only traversal sublist)
	  (only (chicken string) string-split conc)
	  (only (chicken io) read-string)
	  (only (chicken file) file-exists?)
	  (only (srfi-1) fold)
	  (srfi-69))			; hash map

  (import tokenizer
	  c-types)

;;; File Entry type stored in source-files.
  (define (make-fe token-lines)
    (list '*fe*
	  token-lines
	  (make-types-env token-lines)))
  
  (define (fe-token-lines fe)
    (if (and (pair? fe)
	     (eq? (car fe)
		  '*fe*))
	(cadr fe)
	(error "fe-token-lines, not a file entry" fe)))
  
  (define (fe-types-env fe)
    (if (and (pair? fe)
	     (eq? (car fe)
		  '*fe*))
	(caddr fe)
	(error "fe-types-env, not a file entry" fe)))

  (define source-files
    (make-hash-table equal?))

;;; Create a sublist without exceeding the range of `lst`.
;;; Saturates on both ends if either index is out of range.
  (define (sat-sublist lst start end)
    (define (sat-start)
      (cond ((< start 0)
	     0)
	    ((< start (length lst))
	     start)
	    (else
	     ;; The start index is inclusive.
	     (- (length lst) 1))))
    (define (sat-end)
      (cond ((< end 0)
	     0)
	    ((< end (length lst))
	     end)
	    (else
	     ;; The end index is exclusive.
	     (length lst))))
    (sublist lst (sat-start) (sat-end)))


;;; Return a list of all lines in the file behind
;;; filepath or #f if the file can't be read.
  (define (file->list filepath)
    ;; By keeping empty strings when splitting the
    ;; content at the newline characters, we accidentally
    ;; add another empty string to the end of the lines
    ;; list that's generated by the trailing newline at
    ;; the end of the file. The lines list is printed by
    ;; appending a newline to the end of each entry. Thereby
    ;; we bascially add another line to the end of the file
    ;; that doesn't actually exist. Here that line is removed.
    (define (omit-trailing-line! lines)
      (define (before-last lst)
	(if (null? lst)
	    '()
	    (let loop ((current lst)
		       (next (cdr lst)))
	      (if (null? (cdr next))
		  current
		  (loop (cdr current)
			(cdr next))))))
      (let ((pen (before-last lines)))
	(cond ((null? pen)
	       '())
	      ((equal? (cadr pen) "")
	       (set! (cdr pen) '())
	       lines)
	      (else
	       lines))))

    (call-with-input-file filepath
      (lambda (port)
	(if (not port)
	    #f
	    (let ((content (read-string #f port)))
	      (if (not content)
		  #f
		  (omit-trailing-line!
		   (string-split content "\n" #t))))))))
  
;;; Load a file entry for the file behind `filepath`.
  (define (load-fe! filepath)
    (let ((token-lines (tokenize
			(file->list filepath))))
      (if (not token-lines)
	  #f
	  (let ((fe (make-fe token-lines)))
	    (hash-table-set! source-files
			     filepath
			     fe)
	    ;; Return what we've just inserted.
	    (hash-table-ref source-files
			    filepath)))))

;;; Return the file entry for the file behind
;;; `filepath` or #f if `filepath` doesn't exits.
  (define (get-fe filepath)
    (let ((lookup (hash-table-ref/default source-files
					  filepath
					  #f)))
      (if (not lookup)
	  (load-fe! filepath)
	  lookup)))

  (define (start-lineno lineno n-context-lines)
    (if (> lineno n-context-lines)
	(- lineno n-context-lines)
        1))

  (define (end-lineno lineno n-context-lines)
    (+ lineno n-context-lines 1
       ;; Extend window downward if there
       ;; aren't enough lines above.
       (if (< lineno n-context-lines)
	   (- n-context-lines lineno)
	   0)))

  (define (line-window lines lineno n-context-lines)
    (let ((start-lineno (start-lineno lineno n-context-lines))
	  (end-lineno (end-lineno lineno n-context-lines)))
      (sat-sublist lines
		   (- start-lineno 1)
		   (- end-lineno 1))))

;;; Print the source code at the `filepath`:`lineno` with
;;; `n-context-lines` above and below `lineno`. Returns #f
;;; on error and #t on success.
  (define (print-source filepath lineno n-context-lines use-color)
    (let ((fe (get-fe filepath))
	  (start-lineno (start-lineno lineno n-context-lines)))
      (if (not fe)
	  #f
	  (begin
	    (display
    	     (color-tokens
	      (line-window (fe-token-lines fe)
			   lineno
			   n-context-lines)
	      (fe-types-env fe)
	      start-lineno
	      lineno
	      use-color))
	    #t))))
  ;; End module print-source.
  )

(import print-source)

(cond-expand
  ;; FFI is not allowed in interpreted mode.
  (compiling
   (begin
     (import (chicken foreign)
	     (chicken platform))
     (define-external (print_source_extern (c-string filepath)
					   (unsigned-int lineno)
					   (unsigned-int n_context_lines)
					   (bool use-color))
       int
       (if (print-source filepath lineno n_context_lines use-color)
	   0
	   -1))
     (return-to-host)))
  (else ))
