(load  "src/colorize.scm")

(module source-files (print-source)
  (import scheme
	  (chicken base)
	  (only (chicken string) string-split conc)
	  (only (chicken io) read-string)
	  (only (chicken file) file-exists?)
	  (only (srfi-1) fold)
	  (srfi-69))			; hash map

  (import colorizer)

  (define source-files
    (make-hash-table equal?))

  ;;; Create a subvector without exceeding the range of `vec`.
  ;;; Saturates on both ends if either index is out of range.
  (define (sat-subvector vec start end)
    (define (sat-start)
      (cond ((< start 0)
	     0)
	    ((< start (vector-length vec))
	     start)
	    (else
	     ;; The start index is inclusive.
	     (- (vector-length vec) 1))))
    (define (sat-end)
      (cond ((< end 0)
	     0)
	    ((< end (vector-length vec))
	     end)
	    (else
	     ;; The end index is exclusive.
	     (vector-length vec))))
    (subvector vec (sat-start) (sat-end)))

  (define (vector-head vec end)
    (sat-subvector vec 0 end))


;;; Return a vector of all lines in the file behind
;;; filepath or #f if the file can't be read.
  (define (file->vector filepath)
    ;; By keeping empty strings when splitting the
    ;; content at the newline characters, we accidentally
    ;; add another empty string to the end of the lines
    ;; vector that's generated by the trailing newline at
    ;; the end of the file. The lines vector is printed by
    ;; appending a newline to the end of each entry. Thereby
    ;; we bascially add another line to the end of the file
    ;; that doesn't actually exist. Here that line is removed.
    (define (omit-trailing-line lines)
      (let ((last-idx (- (vector-length lines) 1)))
	(let ((last (vector-ref lines last-idx)))
	  (if (equal? last "")
	      (vector-head lines last-idx)
	      lines))))

    (call-with-input-file filepath
      (lambda (port)
	(if (not port)
	    #f
	    (let ((content (read-string #f port)))
	      (if (not content)
		  #f
		  (omit-trailing-line
		   (list->vector
		    (string-split content "\n" #t)))))))))
  
  ;;; Load all lines in the file behind `filepath` into
  ;;; the `source-files` hash table. Returns #f if the
  ;;; file doesn't exists.
  (define (load-source-lines! filepath)
    (let ((lines (file->vector filepath)))
      (if (not lines)
	  #f
	  (begin
	    (hash-table-set! source-files
			     filepath
			     lines)
	    ;; Return what we've just inserted.
	    (hash-table-ref source-files
			    filepath)))))

  ;;; Return the lines in the file behind `filepath`
  ;;; or #f if `filepath` doesn't exits.
  (define (get-source-lines filepath)
    (let ((lookup (hash-table-ref/default source-files
					  filepath
					  #f)))
      (if (not lookup)
	  (load-source-lines! filepath)
	  lookup)))

  (define (start-lineno lineno n-context-lines)
    (if (> lineno n-context-lines)
	(- lineno n-context-lines)
        1))

  (define (end-lineno lineno n-context-lines)
    (+ lineno n-context-lines 1
       ;; Extend window downward if there
       ;; aren't enough lines above.
       (if (< lineno n-context-lines)
	   (- n-context-lines lineno)
	   0)))

  (define (line-window lines lineno n-context-lines)
    (let ((start-lineno (start-lineno lineno n-context-lines))
	  (end-lineno (end-lineno lineno n-context-lines)))
      (vector->list
       ;; Line numbers are one-indexed. Vectors start at 0.
       (sat-subvector lines
		       (- start-lineno 1)
		       (- end-lineno 1)))))

  ;;; Print the source code at the `filepath`:`lineno` with
  ;;; `n-context-lines` above and below `lineno`. Returns #f
  ;;; on error and #t on success.
  (define (print-source filepath lineno n-context-lines use-color)
    (let ((lines (get-source-lines filepath)))
      (if (not lines)
	  #f
	  (begin
	    (display
    	     (colored->string
	      (colorize
	       (line-window lines lineno n-context-lines))
	      (start-lineno lineno n-context-lines)
	      lineno
	      use-color))
	    #t))))
  )  ; module source-files.

(import source-files)

(cond-expand
  ;; FFI is not allowed in interpreted mode.
  (compiling
   (begin
     (import (chicken foreign)
	     (chicken platform))
     (define-external (print_source_extern (c-string filepath)
					   (unsigned-int lineno)
					   (unsigned-int n_context_lines)
					   (bool use-color))
       int
       (if (print-source filepath lineno n_context_lines use-color)
	   0
	   -1))
     (return-to-host)))
  (else ))
